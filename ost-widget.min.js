// ========== GLOBAL VARIABLES ==========
let countdownEndDate = null;
let originalDuration = null;
let lastShownDate = null;
let timerInterval = null;
let timerStarted = false;

// ========== UTILITY FUNCTIONS ==========
function isMobile() {
    return window.innerWidth <= 768;
}

function getScrollPercentage() {
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const documentHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
    return documentHeight > 0 ? (scrollTop / documentHeight) * 100 : 0;
}

function padZero(num) {
    return num.toString().padStart(2, '0');
}

// ========== PERSISTENT TIMER FUNCTIONS ==========
function getTimerStorageKey() {
    return 'countdownTimer_endDate';
}

function saveTimerEndDate(endDate) {
    if (typeof(Storage) !== "undefined") {
        localStorage.setItem(getTimerStorageKey(), endDate.toISOString());
        
        if (countdownConfig.debugMode) {
            console.log('Timer end date saved to localStorage:', endDate.toISOString());
        }
    }
}

function loadTimerEndDate() {
    if (typeof(Storage) !== "undefined") {
        const saved = localStorage.getItem(getTimerStorageKey());
        if (saved) {
            const endDate = new Date(saved);
            
            if (countdownConfig.debugMode) {
                console.log('Timer end date loaded from localStorage:', endDate.toISOString());
            }
            return endDate;
        }
    }
    return null;
}

function clearTimerStorage() {
    if (typeof(Storage) !== "undefined") {
        localStorage.removeItem(getTimerStorageKey());
        
        if (countdownConfig.debugMode) {
            console.log('Timer storage cleared');
        }
    }
}

// Initialize timer with persistence
function initializePersistentTimer() {
    // Try to load existing end date from storage
    const savedEndDate = loadTimerEndDate();
    
    if (savedEndDate && savedEndDate > new Date()) {
        // Timer is still running - use saved end date
        countdownEndDate = savedEndDate;
        
        if (countdownConfig.debugMode) {
            console.log('Continuing existing timer - ends at:', countdownEndDate.toISOString());
        }
    } else {
        // No valid saved timer - start new one
        if (savedEndDate) {
            // Clear expired timer from storage
            clearTimerStorage();
        }
        
        countdownEndDate = calculateEndDateFromDuration(countdownConfig.duration);
        saveTimerEndDate(countdownEndDate);
        
        if (countdownConfig.debugMode) {
            console.log('Starting new timer - ends at:', countdownEndDate.toISOString());
        }
    }
    
    return countdownEndDate;
}

// Calculate end date from duration
function calculateEndDateFromDuration(duration) {
    const now = new Date();
    const totalMilliseconds = (
        (duration.days || 0) * 24 * 60 * 60 * 1000 +
        (duration.hours || 0) * 60 * 60 * 1000 +
        (duration.minutes || 0) * 60 * 1000 +
        (duration.seconds || 0) * 1000
    );
    
    return new Date(now.getTime() + totalMilliseconds);
}

// Store original duration for restart
function storeOriginalDuration() {
    originalDuration = {
        days: countdownConfig.duration.days || 0,
        hours: countdownConfig.duration.hours || 0,
        minutes: countdownConfig.duration.minutes || 0,
        seconds: countdownConfig.duration.seconds || 0
    };
}

function calculateTimeLeft() {
    if (!countdownEndDate) {
        return {
            days: 0,
            hours: 0,
            minutes: 0,
            seconds: 0,
            expired: true
        };
    }

    const now = new Date().getTime();
    const endTime = countdownEndDate.getTime();
    const difference = endTime - now;

    if (difference <= 0) {
        return {
            days: 0,
            hours: 0,
            minutes: 0,
            seconds: 0,
            expired: true
        };
    }

    // Round total seconds up so we never "lose" a second
    let totalSeconds = Math.ceil(difference / 1000);

    const days = Math.floor(totalSeconds / (24 * 60 * 60));
    totalSeconds -= days * 24 * 60 * 60;

    const hours = Math.floor(totalSeconds / (60 * 60));
    totalSeconds -= hours * 60 * 60;

    const minutes = Math.floor(totalSeconds / 60);
    totalSeconds -= minutes * 60;

    const seconds = totalSeconds; // already adjusted

    return {
        days,
        hours,
        minutes,
        seconds,
        totalSeconds: days * 86400 + hours * 3600 + minutes * 60 + seconds,
        expired: false
    };
}

function calculateHeaderHeight() {
    let headerHeight = 0;
    const potentialHeaders = document.querySelectorAll('header, .header, .navbar, .nav');
    
    potentialHeaders.forEach(header => {
        const styles = window.getComputedStyle(header);
        if (styles.position === 'fixed' || styles.position === 'sticky') {
            headerHeight = Math.max(headerHeight, header.offsetHeight);
        }
    });
    
    return headerHeight;
}

function applyResponsivePositioning() {
    const countdown = document.getElementById('stickyCountdown');
    if (!countdown) return;

    const currentIsMobile = isMobile();
    
    // Remove all position and alignment classes
    countdown.classList.remove('position-top', 'position-bottom');
    countdown.classList.remove('align-left', 'align-center', 'align-right');

    // Remove existing body padding
    // const body = document.body;
    // body.classList.remove('sticky-countdown-top-active', 'sticky-countdown-bottom-active');

    // Apply current device-specific classes
    const position = currentIsMobile ? countdownConfig.position.mobile : countdownConfig.position.desktop;
    const alignment = currentIsMobile ? countdownConfig.alignment.mobile : countdownConfig.alignment.desktop;
    
    countdown.classList.add(`position-${position}`);
    countdown.classList.add(`align-${alignment}`);

    if (countdownConfig.debugMode) {
        console.log(`Applied ${currentIsMobile ? 'mobile' : 'desktop'} positioning: ${position}-${alignment}`);
    }
}

function applyBodyPadding() {
    const body = document.body;
    const countdown = document.getElementById('stickyCountdown');
    const currentIsMobile = isMobile();
    const position = currentIsMobile ? countdownConfig.position.mobile : countdownConfig.position.desktop;
    
    // Remove both classes first
    body.classList.remove('sticky-countdown-top-active', 'sticky-countdown-bottom-active');
    
    if (currentIsMobile && countdown) {
        // Calculate actual countdown height
        const countdownHeight = countdown.offsetHeight;
        const paddingValue = countdownHeight + 10;
        
        // Apply dynamic padding based on position
        if (position === 'bottom') {
            body.style.paddingBottom = paddingValue + 'px';
            body.style.paddingTop = ''; // Clear top padding
        } else {
            body.style.paddingTop = paddingValue + 'px';
            body.style.paddingBottom = ''; // Clear bottom padding
        }
        
        if (countdownConfig.debugMode) {
            console.log(`Applied dynamic mobile padding: ${paddingValue}px (countdown height: ${countdownHeight}px)`);
        }
    } else if (!currentIsMobile) {
        // For desktop, use the class-based approach
        const bodyClass = position === 'bottom' ? 'sticky-countdown-bottom-active' : 'sticky-countdown-top-active';
        body.classList.add(bodyClass);
        
        // Clear any inline padding styles from mobile
        body.style.paddingTop = '';
        body.style.paddingBottom = '';
        
        if (countdownConfig.debugMode) {
            console.log(`Applied desktop padding class: ${bodyClass}`);
        }
    }
}

function checkAndApplyInitialBodyPadding() {
    const countdown = document.getElementById('stickyCountdown');
    
    if (countdown && countdown.classList.contains('expired')) {
        applyBodyPadding();
        
        if (countdownConfig.debugMode) {
            console.log('Applied initial body padding on page load');
        }
    }
}

function updateButtonText() {
    if (!countdownConfig.dynamicText.enabled || !countdownConfig.dynamicText.textChanges.length) {
        return;
    }

    const countdownBtn = document.getElementById('countdownBtn');
    const buttonText = countdownBtn.querySelector('.btn-text');
    if (!buttonText) return;

    const currentIsMobile = isMobile();
    const scrollPercentage = getScrollPercentage();
    let activeText = countdownConfig.dynamicText.defaultText;
    
    // Process text changes in order to find the most recent applicable one
    for (let i = 0; i < countdownConfig.dynamicText.textChanges.length; i++) {
        const textChange = countdownConfig.dynamicText.textChanges[i];
        let shouldTrigger = false;
        
        if (textChange.triggerType === 'percentage') {
            // Handle percentage-based triggers
            const triggerPercentage = currentIsMobile ? 
                (typeof textChange.trigger === 'object' ? textChange.trigger.mobile : textChange.trigger) :
                (typeof textChange.trigger === 'object' ? textChange.trigger.desktop : textChange.trigger);
            
            shouldTrigger = scrollPercentage >= triggerPercentage;
            
            if (countdownConfig.debugMode && shouldTrigger) {
                console.log(`Percentage trigger ${i + 1} activated at ${scrollPercentage.toFixed(1)}% (threshold: ${triggerPercentage}%)`);
            }
        } else if (textChange.triggerType === 'element') {
            // Handle element-based triggers
            const targetElement = document.getElementById(textChange.trigger);
            if (targetElement) {
                const elementRect = targetElement.getBoundingClientRect();
                const offset = textChange.offset || 0;
                shouldTrigger = elementRect.top <= offset;
                
                if (countdownConfig.debugMode && shouldTrigger) {
                    console.log(`Element trigger ${i + 1} activated for element #${textChange.trigger} (top: ${elementRect.top}, offset: ${offset})`);
                }
            } else if (countdownConfig.debugMode) {
                console.warn(`Element with id "${textChange.trigger}" not found for trigger ${i + 1}`);
            }
        }
        
        if (shouldTrigger) {
            activeText = textChange.text;
        }
    }

    // Only update if text has changed to avoid unnecessary DOM updates
    if (buttonText.textContent !== activeText) {
        buttonText.textContent = activeText;
        
        if (countdownConfig.debugMode) {
            console.log(`Button text updated to: "${activeText}"`);
        }
    }
}

function isTimeBelow(timeLeft, threshold) {
    // Convert both times to total seconds for easier comparison
    const timeLeftSeconds = (timeLeft.days * 24 * 60 * 60) + 
                            (timeLeft.hours * 60 * 60) + 
                            (timeLeft.minutes * 60) + 
                            timeLeft.seconds;
                            
    const thresholdSeconds = (threshold.days * 24 * 60 * 60) + 
                            (threshold.hours * 60 * 60) + 
                            (threshold.minutes * 60) + 
                            threshold.seconds;
                            
    return timeLeftSeconds <= thresholdSeconds;
}

// Function to disable/enable order form fields
function setOrderFormDisabled(disabled) {
    const orderForm = document.getElementById('order_form');
    if (!orderForm) return;
    
    if (disabled) {
        orderForm.classList.add('form-disabled');
        // Disable all form inputs
        const inputs = orderForm.querySelectorAll('input, select, textarea, button');
        inputs.forEach(input => {
            input.disabled = true;
            input.setAttribute('data-was-disabled', 'true');
        });
    } else {
        orderForm.classList.remove('form-disabled');
        // Enable all form inputs that were previously disabled by us
        const inputs = orderForm.querySelectorAll('input, select, textarea, button');
        inputs.forEach(input => {
            if (input.getAttribute('data-was-disabled') === 'true') {
                input.disabled = false;
                input.removeAttribute('data-was-disabled');
            }
        });
    }
}

// Function to control form visibility and state
function controlFormState(state) {
    const form = document.getElementById('form');
    
    if (!form) return;
    
    // Reset states
    setOrderFormDisabled(false);
    form.classList.remove('hidden');
    
    switch(state) {
        case 'hide':
            form.classList.add('hidden');
            break;
        case 'disable':
            setOrderFormDisabled(true);
            break;
        case 'show':
            form.classList.remove('hidden');
            setOrderFormDisabled(false);
            break;
        default:
            form.classList.remove('hidden');
            setOrderFormDisabled(false);
            break;
    }
    
    if (countdownConfig.debugMode) {
        console.log(`Form state changed to: ${state}`);
    }
}

// Handle timer expiration and restart
function handleTimerExpiration() {
    const countdown = document.getElementById('stickyCountdown');
    const countdownButton = document.getElementById('countdownBtn');
    const titleElement = document.getElementById('countdownTitle');
    
    countdown.classList.add('expired');
    countdown.classList.remove('warning', 'urgency-pulse');

    if (titleElement && countdownConfig.expiredTitle) {
        titleElement.textContent = countdownConfig.expiredTitle;
    }

    // Stop the timer since it's expired
    stopCountdownTimer();
    
    // Clear the persistent storage since timer expired
    clearTimerStorage();
    
    // Save the expiration date for frequency tracking
    saveLastShownDate();
    
    countdownButton.classList.add('hidden');

    setTimeout(() => {
        applyBodyPadding();
    }, 50);

    controlFormState(countdownConfig.formBehaviorOnExpired);
    
    // Handle frequency-based restart logic ONLY for same-session restarts
    if (countdownConfig.frequency > 0) {
        // Schedule next appearance based on frequency (for same session only)
        const nextShowTime = countdownConfig.frequency * 24 * 60 * 60 * 1000;
        
        setTimeout(() => {
            // Only restart if page is still open and frequency time has passed
            if (shouldShowCountdown()) {
                restartFreshTimer();
            }
        }, nextShowTime);
        
        if (countdownConfig.debugMode) {
            console.log(`Timer will restart in ${countdownConfig.frequency} days if page remains open`);
        }
    }
}

// Restart with fresh timer
function restartFreshTimer() {
    if (!originalDuration) {
        if (countdownConfig.debugMode) {
            console.log('Cannot restart: no original duration stored');
        }
        return;
    }
    
    const countdown = document.getElementById('stickyCountdown');
    const countdownButton = document.getElementById('countdownBtn');
    const titleElement = document.getElementById('countdownTitle');
    
    // Create new timer and save it
    countdownEndDate = calculateEndDateFromDuration(originalDuration);
    saveTimerEndDate(countdownEndDate);
    timerStarted = false; // Reset timer started flag
    
    // Remove expired state
    countdown.classList.remove('expired');
    
    // Restore title
    if (titleElement) {
        titleElement.textContent = countdownConfig.title;
        titleElement.style.display = countdownConfig.showTitle ? 'block' : 'none';
    }
    
    // Restore button visibility
    if (countdownButton) {
        countdownButton.classList.remove('hidden');
    }
    
    // The timer will start when showCountdown() is called and widget becomes visible
    
    if (countdownConfig.debugMode) {
        console.log('Fresh timer restarted and saved to storage - will begin counting when widget becomes visible');
    }
}

function updateTimer() {
    const timeLeft = calculateTimeLeft();
    
    // Update display
    document.getElementById('days').textContent = padZero(timeLeft.days);
    document.getElementById('hours').textContent = padZero(timeLeft.hours);
    document.getElementById('minutes').textContent = padZero(timeLeft.minutes);
    document.getElementById('seconds').textContent = padZero(timeLeft.seconds);
    
    const countdown = document.getElementById('stickyCountdown');
    
    if (timeLeft.expired) {
        handleTimerExpiration();
    } else {
        countdown.classList.remove('expired');
        
        // Ensure buttons are visible during countdown
        const countdownButton = document.getElementById('countdownBtn');
        
        if (countdownButton) {
            countdownButton.classList.remove('hidden');
        }
        
        // Check for urgency animation (highest priority)
        if (countdownConfig.urgencyState.enabled && 
            isTimeBelow(timeLeft, countdownConfig.urgencyState.threshold)) {
            
            countdown.classList.add('urgency', 'urgency-pulse');
            countdown.classList.remove('warning');
            
            if (countdownConfig.debugMode) {
                console.log('Urgency state activated - Time remaining:', timeLeft);
            }
        }
        // Check for warning animation (medium priority)
        else if (countdownConfig.warningState.enabled && isTimeBelow(timeLeft, countdownConfig.warningState.threshold)) {
            
            countdown.classList.add('warning');
            countdown.classList.remove('urgency', 'urgency-pulse');
            
            if (countdownConfig.debugMode) {
                console.log('Warning state activated - Time remaining:', timeLeft);
            }
        }
        // Normal state (lowest priority)
        else {
            countdown.classList.remove('warning', 'urgency', 'urgency-pulse');
        }
    }
}

// Start the countdown timer
function startCountdownTimer() {
    if (timerStarted || !countdownEndDate) return;
    
    timerStarted = true;
    
    // Update immediately
    updateTimer();
    
    // Start the interval
    timerInterval = setInterval(updateTimer, 1000);

    // Restore the initial title
    const titleElement = document.getElementById('countdownTitle');
    if (titleElement) {
        titleElement.textContent = countdownConfig.title;
        titleElement.style.display = countdownConfig.showTitle ? 'block' : 'none';
    }
    
    if (countdownConfig.debugMode) {
        console.log('Countdown timer started');
    }
}

// Stop the countdown timer
function stopCountdownTimer() {
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
    timerStarted = false;
    
    if (countdownConfig.debugMode) {
        console.log('Countdown timer stopped');
    }
}

// Reset the countdown timer
function resetCountdownTimer() {
    stopCountdownTimer();
    
    if (originalDuration) {
        countdownEndDate = calculateEndDateFromDuration(originalDuration);
        saveTimerEndDate(countdownEndDate);
        
        if (countdownConfig.debugMode) {
            console.log('Countdown timer reset to original duration and saved');
        }
    }
}

// ========== FREQUENCY MANAGEMENT FUNCTIONS ==========
function getStorageKey() {
    return 'countdownTimer_lastShown';
}

function saveLastShownDate() {
    if (typeof(Storage) !== "undefined") {
        const now = new Date();
        localStorage.setItem(getStorageKey(), now.toISOString());
        lastShownDate = now;
        
        if (countdownConfig.debugMode) {
            console.log('Last shown date saved:', now.toISOString());
        }
    }
}

function loadLastShownDate() {
    if (typeof(Storage) !== "undefined") {
        const saved = localStorage.getItem(getStorageKey());
        if (saved) {
            lastShownDate = new Date(saved);
            
            if (countdownConfig.debugMode) {
                console.log('Last shown date loaded:', lastShownDate.toISOString());
            }
            return lastShownDate;
        }
    }
    return null;
}

function shouldShowCountdown() {
    // If frequency is 0, always show
    if (countdownConfig.frequency === 0) {
        return true;
    }
    
    const lastShown = loadLastShownDate();
    
    // If never shown before, show it
    if (!lastShown) {
        return true;
    }
    
    // Calculate if enough time has passed
    const now = new Date();
    const daysSinceLastShown = (now - lastShown) / (1000 * 60 * 60 * 24);
    const shouldShow = daysSinceLastShown >= countdownConfig.frequency;
    
    if (countdownConfig.debugMode) {
        console.log('Frequency check:', {
            lastShown: lastShown.toISOString(),
            daysSinceLastShown: daysSinceLastShown.toFixed(2),
            frequencyDays: countdownConfig.frequency,
            shouldShow: shouldShow
        });
    }
    
    return shouldShow;
}

// ========== LAZY LOADING DETECTION ==========
function waitForLazyLoad(targetPosition, callback) {
    let startTime = Date.now();
    let lastDocumentHeight = document.documentElement.scrollHeight;
    let stableCount = 0;
    
    const checkStability = () => {
        const currentHeight = document.documentElement.scrollHeight;
        const currentTime = Date.now();
        
        // Check if document height has changed
        if (currentHeight !== lastDocumentHeight) {
            lastDocumentHeight = currentHeight;
            stableCount = 0;
            
            if (countdownConfig.debugMode) {
                console.log(`Document height changed to ${currentHeight}px`);
            }
        } else {
            stableCount++;
        }
        
        // Consider stable after 3 consecutive checks with no change
        // or if timeout is reached
        if (stableCount >= 3 || (currentTime - startTime) >= 3000) {
            // Recalculate target position after lazy loading
            const targetElement = document.getElementById(countdownConfig.buttonAction.target);
            if (targetElement) {
                const newTargetRect = targetElement.getBoundingClientRect();
                const newTargetTop = newTargetRect.top + window.pageYOffset;
                const headerHeight = calculateHeaderHeight();
                const newFinalPosition = Math.max(0, 
                    newTargetTop - headerHeight - countdownConfig.scrollBehavior.offsetTop
                );
                
                // Only scroll if position has significantly changed
                if (Math.abs(newFinalPosition - targetPosition) > 20) {
                    window.scrollTo({
                        top: newFinalPosition,
                        behavior: countdownConfig.scrollBehavior.behavior
                    });
                    
                    if (countdownConfig.debugMode) {
                        console.log(`Adjusted scroll position after lazy loading: ${newFinalPosition}px`);
                    }
                }
            }
            
            callback();
            return;
        }
        
        setTimeout(checkStability, 100);
    };
    
    checkStability();
}

function showCountdown() {
    const countdown = document.getElementById('stickyCountdown');
    if (!countdown || countdown.classList.contains('visible')) return;
    
    // Remove any existing animation classes
    countdown.classList.remove('entrance', 'exit');
    
    // Apply entrance animation based on position
    countdown.classList.add('entrance');
    countdown.classList.add('visible');

    applyBodyPadding();

    // Initialize persistent timer if not already done
    if (!countdownEndDate) {
        storeOriginalDuration();
        initializePersistentTimer();
        
        if (countdownConfig.debugMode) {
            console.log('Persistent timer initialized when widget became visible');
        }
    }

    // START THE TIMER WHEN WIDGET BECOMES VISIBLE
    startCountdownTimer();
    
    if (countdownConfig.debugMode) {
        console.log('Countdown timer shown with entrance animation and timer started');
    }
}

function showExpiredCountdown() {
    const countdown = document.getElementById('stickyCountdown');
    const titleElement = document.getElementById('countdownTitle');
    const countdownButton = document.getElementById('countdownBtn');
    
    if (!countdown) return;

    // Remove any existing animation classes first
    countdown.classList.remove('entrance', 'exit');
    
    // Apply expired state styling
    countdown.classList.add('expired');
    countdown.classList.remove('warning', 'urgency', 'urgency-pulse');

    // Add entrance animation AND visible class
    countdown.classList.add('entrance', 'visible');
    
    // Set expired title
    if (titleElement && countdownConfig.expiredTitle) {
        titleElement.textContent = countdownConfig.expiredTitle;
        titleElement.style.display = countdownConfig.showTitle ? 'block' : 'none';
    }
    
    // Hide the button since timer is expired
    if (countdownButton) {
        countdownButton.classList.add('hidden');
    }
    
    // Set timer display to 00:00:00:00
    document.getElementById('days').textContent = '00';
    document.getElementById('hours').textContent = '00';
    document.getElementById('minutes').textContent = '00';
    document.getElementById('seconds').textContent = '00';
    
    // Apply responsive positioning
    applyResponsivePositioning();

    setTimeout(() => {
        applyBodyPadding();
    }, 100);
    
    if (countdownConfig.debugMode) {
        console.log('Expired countdown state displayed');
    }
}

function hideCountdown() {
    const countdown = document.getElementById('stickyCountdown');
    if (!countdown) return;
    
    // Apply exit animation
    countdown.classList.add('exit');
    countdown.classList.remove('visible', 'warning', 'urgency', 'urgency-pulse');
    
    // STOP THE TIMER WHEN WIDGET IS HIDDEN
    stopCountdownTimer();
    
    // Remove exit class after animation completes
    setTimeout(() => {
        countdown.classList.remove('exit', 'entrance');
    }, 400);
    
    if (countdownConfig.debugMode) {
        console.log('Countdown timer hidden with exit animation and timer stopped');
    }
}

function handleButtonClick(event) {
    event.preventDefault();
    
    const action = countdownConfig.buttonAction;
    
    switch (action.type) {
        case 'scroll':
            const targetElement = document.getElementById(action.target);
            if (!targetElement) {
                console.error(`Target element with id "${action.target}" not found!`);
                return;
            }

            // Calculate initial scroll position
            const targetRect = targetElement.getBoundingClientRect();
            const targetTop = targetRect.top + window.pageYOffset;
            const headerHeight = calculateHeaderHeight();
            const finalScrollPosition = Math.max(0, 
                targetTop - headerHeight - countdownConfig.scrollBehavior.offsetTop
            );

            // Perform initial scroll
            window.scrollTo({
                top: finalScrollPosition,
                behavior: countdownConfig.scrollBehavior.behavior
            });

            // Wait for lazy loading and adjust if necessary
            waitForLazyLoad(finalScrollPosition, () => {
                if (countdownConfig.debugMode) {
                    console.log('Scroll to target completed, including lazy load adjustments');
                }
            });

            if (countdownConfig.debugMode) {
                console.log('Scrolled to target:', {
                    targetElement: action.target,
                    targetTop: targetTop,
                    headerHeight: headerHeight,
                    offset: countdownConfig.scrollBehavior.offsetTop,
                    finalPosition: finalScrollPosition
                });
            }
            break;
            
        case 'url':
            window.open(action.target, '_blank');
            
            if (countdownConfig.debugMode) {
                console.log('Opened URL:', action.target);
            }
            break;
            
        default:
            console.error('Unknown button action type:', action.type);
    }
}

function handleScroll() {
    // Always update button text on scroll, regardless of showMode
    updateButtonText();
    
    if (countdownConfig.showMode !== 'scroll') return;
    
    const currentIsMobile = isMobile();
    const scrollPercentage = getScrollPercentage();
    const threshold = currentIsMobile ? 
        countdownConfig.scrollTrigger.mobile : 
        countdownConfig.scrollTrigger.desktop;

    if (scrollPercentage >= threshold) {
        showCountdown();
    }
}

// ========== DOMAIN VALIDATION FUNCTIONS ==========
async function validateDomain() {
    try {
        // URL untuk fetch senarai domain yang dibenarkan
        const jsonUrl = 'https://cdn.jsdelivr.net/gh/asyraf92/ost-widget@main/ostw-allowed-domains.json';
        
        const response = await fetch(jsonUrl);
        if (!response.ok) {
            if (countdownConfig.debugMode) {
                console.warn('Failed to fetch allowed domains list, allowing all domains');
            }
            return true; // Fallback: allow if can't fetch
        }
        
        const data = await response.json();
        const allowedDomains = data.domains || [];
        const currentDomain = window.location.hostname;
        
        // Check if current domain is in allowed list
        const isAllowed = allowedDomains.some(domain => {
            // Support wildcard subdomains (e.g., *.example.com)
            if (domain.startsWith('*.')) {
                const baseDomain = domain.substring(2);
                return currentDomain.endsWith(baseDomain);
            }
            return currentDomain === domain;
        });
        
        if (countdownConfig.debugMode) {
            console.log('Domain validation:', {
                currentDomain,
                allowedDomains,
                isAllowed
            });
        }
        
        return isAllowed;
        
    } catch (error) {
        if (countdownConfig.debugMode) {
            console.warn('Domain validation error:', error.message, '- allowing all domains');
        }
        return true; // Fallback: allow if error occurs
    }
}

async function initializeCountdown() {
    // Validate domain before initializing
    const isDomainAllowed = await validateDomain();
    if (!isDomainAllowed) {
        if (countdownConfig.debugMode) {
            console.log('Domain not allowed, countdown initialization blocked');
        }
        return; // Exit early if domain not allowed
    }

    const countdown = document.getElementById('stickyCountdown');
    const titleElement = document.getElementById('countdownTitle');
    const buttonElement = countdown.querySelector('.countdown-button');
    const buttonText = countdown.querySelector('.btn-text');
    
    if (!countdown) {
        console.error('Countdown element not found!');
        return;
    }
    
    // Check if countdown should be shown based on frequency
    const shouldShow = shouldShowCountdown();
    let isExpiredState = false;
    
    // Check if we have an existing timer that's expired
    const savedEndDate = loadTimerEndDate();
    if (savedEndDate && savedEndDate <= new Date()) {
        // Clear expired timer
        clearTimerStorage();
        isExpiredState = true;
    }
    
    if (!shouldShow || isExpiredState) { 
        // Timer is in expired state due to frequency restrictions or expired saved timer
        isExpiredState = true;
        controlFormState(countdownConfig.formBehaviorOnExpired);
        showExpiredCountdown();

        if (countdownConfig.debugMode) {
            console.log('Countdown shown in expired state due to frequency restrictions or expired timer');
        }
        
    } else {
        // Frequency period has passed, restore normal state
        controlFormState('show');

        if (countdownConfig.debugMode) {
            console.log('Frequency period has passed, order form restored - timer will initialize when visible');
        }
    }

    // Set title and button text - but preserve expired state
    if (titleElement) {
        if (isExpiredState) {
            // Keep the expired title that was set by showExpiredCountdown()
            titleElement.textContent = countdownConfig.expiredTitle;
        } else {
            // Use normal title for active countdown
            titleElement.textContent = countdownConfig.title;
        }
        titleElement.style.display = countdownConfig.showTitle ? 'block' : 'none';
    }

    if (buttonText) {
        buttonText.textContent = countdownConfig.dynamicText.defaultText;
    }

    if (buttonElement) {
        buttonElement.addEventListener('click', handleButtonClick);
    }

    // Apply responsive positioning
    applyResponsivePositioning();

    // Handle display modes - but only if not in expired state
    if (!isExpiredState) {
        // Check if we have a running timer from storage
        const hasRunningTimer = savedEndDate && savedEndDate > new Date();
        
        if (hasRunningTimer) {
            // If timer is running, always show it regardless of showMode
            showCountdown();
            updateButtonText();
        } else {
            // Only follow showMode logic for new timers
            switch (countdownConfig.showMode) {
                case 'always':
                    showCountdown(); // This will initialize persistent timer and start
                    updateButtonText();
                    break;
                    
                case 'scroll':
                    let ticking = false;
                    window.addEventListener('scroll', () => {
                        if (!ticking) {
                            requestAnimationFrame(() => {
                                handleScroll();
                                ticking = false;
                            });
                            ticking = true;
                        }
                    });
                    handleScroll(); // This may trigger showCountdown() if scroll threshold is met
                    break;
                    
                case 'timed':
                    setTimeout(() => {
                        showCountdown(); // This will initialize persistent timer and start after delay
                        updateButtonText();
                    }, countdownConfig.timedDisplay.delay * 1000);
                    break;
            }
        }

        // Add scroll listener for dynamic text changes (regardless of showMode)
        if (countdownConfig.dynamicText.enabled && countdownConfig.showMode !== 'scroll') {
            let textTicking = false;
            window.addEventListener('scroll', () => {
                if (!textTicking) {
                    requestAnimationFrame(() => {
                        updateButtonText();
                        textTicking = false;
                    });
                    textTicking = true;
                }
            });
        }
    }

    // This ensures padding is maintained after page refresh
    setTimeout(() => {
        checkAndApplyInitialBodyPadding();
    }, 100);

    if (countdownConfig.debugMode) {
        console.log('Countdown timer initialized', { isExpiredState, shouldShow, hasSavedTimer: !!savedEndDate });
    }
}

// Handle window resize for responsive behavior
function handleResize() {
    applyResponsivePositioning();

    // Reapply body padding on resize if countdown is visible
    const countdown = document.getElementById('stickyCountdown');
    if (countdown && countdown.classList.contains('visible')) {
        // Use setTimeout to ensure the countdown has finished resizing
        setTimeout(() => {
            applyBodyPadding();
        }, 100);
    }
    
    if (countdownConfig.showMode === 'scroll') {
        handleScroll();
    } else {
        updateButtonText();
    }
}

// ========== INITIALIZATION ==========
document.addEventListener('DOMContentLoaded', async () => {
    await initializeCountdown();
    
    // Add resize listener with throttling
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(handleResize, 150);
    });
});